r"""This module contains a base class for a Uniform Matrix Product State (MPS).

An MPS looks roughly like this::

    |   -- B[0] -- B[1] -- B[2] -- ...
    |       |       |      |

We use the following label convention for the `B` (where arrows indicate `qconj`)::

    |  vL ->- B ->- vR
    |         |
    |         ^
    |         p

We store one 3-leg tensor `_B[i]` with labels ``'vL', 'vR', 'p'`` for each of the `L` sites
``0 <= i < L``.
Additionally, we store ``L+1`` singular value arrays `_S[ib]` on each bond ``0 <= ib <= L``,
independent of the boundary conditions.
``_S[ib]`` gives the singlur values on the bond ``i-1, i``.
However, be aware that e.g. :attr:`~tenpy.networks.mps.MPS.chi` returns only the dimensions of the
:attr:`~tenpy.networks.mps.MPS.nontrivial_bonds` depending on the boundary conditions.

The matrices and singular values always represent a normalized state
(i.e. ``np.linalg.norm(psi._S[ib]) == 1`` up to roundoff errors),
but (for finite MPS) we keep track of the norm in :attr:`~tenpy.networks.mps.MPS.norm`
(which is respected by :meth:`~tenpy.networks.mps.MPS.overlap`, ...).

Valid MPS boundary conditions (not to confuse with `bc_coupling` of
:class:`tenpy.models.model.CouplingModel`)  are the following:

==========  ===================================================================================
`bc`        description
==========  ===================================================================================
'finite'    Finite MPS, ``G0 s1 G1 ... s{L-1} G{l-1}``. This is acchieved
            by using a trivial left and right bond ``s[0] = s[-1] = np.array([1.])``.
'segment'   Generalization of 'finite', describes an MPS embedded in left and right
            environments. The left environment is described by ``chi[0]`` *orthonormal* states
            which are weighted by the singular values ``s[0]``. Similar, ``s[L]`` weight some
            right orthonormal states. You can think of the left and right states to be
            generated by additional MPS, such that the overall structure is something like
            ``... s L s L [s0 G0 s1 G1 ... s{L-1} G{L-1} s{L}] R s R s R ...``
            (where we save the part in the brackets ``[ ... ]`` ).
'infinite'  infinite MPS (iMPS): we save a 'MPS unit cell' ``[s0 G0 s1 G1 ... s{L-1} G{L-1}]``
            which is repeated periodically, identifying all indices modulo ``self.L``.
            In particular, the last bond ``L`` is identified with ``0``.
            (The MPS unit cell can differ from a lattice unit cell).
            bond is identified with the first one.
==========  ===================================================================================

An MPS can be in different 'canonical forms' (see :cite:`vidal2004,schollwoeck2011`).
To take care of the different canonical forms, algorithms should use functions like
:meth:`~tenpy.networks.mps.MPS.get_theta`, :meth:`~tenpy.networks.mps.MPS.get_B`
and :meth:`~tenpy.networks.mps.MPS.set_B` instead of accessing them directly,
as they return the `B` in the desired form (which can be chosen as an argument).
The values of the tuples for the form correspond to the exponent of the singular values
on the left and right.
To keep track of a "mixed" canonical form ``A A A s B B``, we save the tuples for each
site of the MPS in :attr:`MPS.form`.

======== ========== ==========================================================================
`form`   tuple      description
======== ========== ==========================================================================
``'B'``  (0, 1)     right canonical: ``_B[i] = -- Gamma[i] -- s[i+1]--``
                    The default form, which algorithms asssume.
``'C'``  (0.5, 0.5) symmetric form: ``_B[i] = -- s[i]**0.5 -- Gamma[i] -- s[i+1]**0.5--``
``'A'``  (1, 0)     left canonical: ``_B[i] = -- s[i] -- Gamma[i] --``.
``'G'``  (0, 0)     Save only ``_B[i] = -- Gamma[i] --``.
``'Th'`` (1, 1)     Form of a local wave function `theta` with singular value on both sides.
                    ``psi.get_B(i, 'Th') is equivalent to ``psi.get_theta(i, n=1)``.
``None`` ``None``   General non-canoncial form.
                    Valid form for initialization, but you need to call
                    :meth:`~tenpy.networks.mps.MPS.canonical_form` (or similar)
                    before using algorithms.
======== ========== ==========================================================================
"""
# Copyright 2018-2021 TeNPy Developers, GNU GPLv3

import numpy as np
import warnings
import random
from functools import reduce
import logging
logger = logging.getLogger(__name__)

from ..linalg import np_conserved as npc
from .mps import MPS

__all__ = ['uMPS']


class uMPS(MPS):
    r"""A Matrix Product State, finite (MPS) or infinite (iMPS).

    Parameters
    ----------
    sites : list of :class:`~tenpy.networks.site.Site`
        Defines the local Hilbert space for each site.
    Bs : list of :class:`~tenpy.linalg.np_conserved.Array`
        The 'matrices' of the MPS. Labels are ``vL, vR, p`` (in any order).
    SVs : list of 1D array
        The singular values on *each* bond. Should always have length `L+1`.
        Entries out of :attr:`nontrivial_bonds` are ignored.
    bc : ``'finite' | 'segment' | 'infinite'``
        Boundary conditions as described in the tabel of the module doc-string.
    form : (list of) {``'B' | 'A' | 'C' | 'G' | 'Th' | None`` | tuple(float, float)}
        The form of the stored 'matrices', see table in module doc-string.
        A single choice holds for all of the entries.

    Attributes
    ----------
    sites : list of :class:`~tenpy.networks.site.Site`
        Defines the local Hilbert space for each site.
    bc : {'finite', 'segment', 'infinite'}
        Boundary conditions as described in above table.
    form : list of {``None``, tuple(float, float)}
        Describes the canonical form on each site.
        ``None`` means non-canonical form.
        For ``form = (nuL, nuR)``, the stored ``_B[i]`` are
        ``s**form[0] -- Gamma -- s**form[1]`` (in Vidal's notation).
    chinfo : :class:`~tenpy.linalg.np_conserved.ChargeInfo`
        The nature of the charge.
    dtype : type
        The data type of the ``_B``.
    norm : float
        The norm of the state, i.e. ``sqrt(<psi|psi>)``.
        Ignored for (normalized) :meth:`expectation_value`, but important for :meth:`overlap`.
    grouped : int
        Number of sites grouped together, see :meth:`group_sites`.
    segment_boundaries : tuple of :class:`~tenpy.linalg.np_conserved.Array` | (None, None)
        Only defined for 'segment' `bc` if :meth:`canonical_form_finite` has been called.
        If defined, it contains the `U_L` and `V_R` that would be returned by that function.
    _B : list of :class:`npc.Array`
        The 'matrices' of the MPS. Labels are ``vL, vR, p`` (in any order).
        We recommend using :meth:`get_B` and :meth:`set_B`, which will take care of the different
        canonical forms.
    _S : list of {``None``, 1D array, :class:`~tenpy.linalg.np_conserved.Array}
        The singular values on each virtual bond, length ``L+1``.
        May be ``None`` if the MPS is not in canonical form.
        Otherwise, ``_S[i]`` is to the left of ``_B[i]``.
        We recommend using :meth:`get_SL`, :meth:`get_SR`, :meth:`set_SL`, :meth:`set_SR`, which
        takes proper care of the boundary conditions.
        Sometimes (e.g. during DMRG with an enabled mixer), entries may temporarily be
        a non-diagonal :class:`tenpy.linalg.np_conserved.Array` to be inserted between the
        left canonical 'A' tensors on the left and rigth-canonical _B[i] on the right.
    _valid_forms : dict
        Class attribute.
        Mapping for canonical forms to a tuple ``(nuL, nuR)`` indicating that
        ``self._Bs[i] = s[i]**nuL -- Gamma[i] -- s[i]**nuR`` is saved.
    _valid_bc : tuple of str
        Class attribute. Possible valid boundary conditions.
    _transfermatrix_keep : int
        How many states to keep at least when diagonalizing a :class:`TransferMatrix`.
        Important if the state develops a near-degeneracy.
    _p_label, _B_labels : list of str
        Class attribute. `_p_label` defines the physical legs of the B-tensors, `_B_labels` lists
        all the labels of the B tensors. Used by methods like :meth:`get_theta` to avoid
        the necessity of re-implementations for derived classes like the
        :class:`~tenpy.networks.purification_mps.Purification_MPS` if just the number of physical
        legs changed.
    """

    # valid boundary conditions. Don't overwrite this!
    _valid_bc = ('infinite')
    # All labels of each tensor in _B (order is used!)
    _C_labels = ['vL', 'vR']

    def __init__(self, sites, ALs, ARs, ACs, Cs, norm=1.):
        self.sites = list(sites)
        self.chinfo = self.sites[0].leg.chinfo
        self.dtype = dtype = np.find_common_type([AL.dtype for AL in ALs], [])
        self.form = [None] * len(ARs)
        self.bc = 'infinite'  # one of ``'finite', 'infinite', 'segment'``.
        self.norm = norm
        self.grouped = 1
        self.segment_boundaries = (None, None)
        self.valid_umps = False # Need to check that AL[n] C[n+1] = AC[n] and C[n] AR[n] = AC[n]
        # make copies of 4 types of tensors
        self._AR = [AR.astype(dtype, copy=True).itranspose(self._B_labels) for AR in ARs]
        self._AL = [AL.astype(dtype, copy=True).itranspose(self._B_labels) for AL in ALs]
        self._AC = [AC.astype(dtype, copy=True).itranspose(self._B_labels) for AC in ACs]
        self._C = [C.astype(dtype, copy=True).itranspose(self._C_labels) for C in Cs] # TODO, same initialization as S?
        # center matrix on the left of site `i`
        self._transfermatrix_keep = 1
        self.test_sanity()

    def test_sanity(self):
        """Sanity check, raises ValueErrors, if something is wrong."""
        assert self.grouped == 1
        assert self.segment_boundaries == (None, None)

        if self.bc not in self._valid_bc:
            raise ValueError("invalid boundary condition: " + repr(self.bc))
        if len(self._AL) != self.L:
            raise ValueError("wrong len of self._AL")
        if len(self._AR) != self.L:
            raise ValueError("wrong len of self._AR")
        if len(self._AC) != self.L:
            raise ValueError("wrong len of self._AC")
        if len(self._C) != self.L:
            raise ValueError("wrong len of self._C")
        assert len(self.form) == self.L

        for i, As in enumerate(zip(self._AL, self._AR, self._AC)):
            AL, AR, AC = As
            if AL.get_leg_labels() != self._B_labels:
                raise ValueError("AL has wrong labels {0!r}, expected {1!r}".format(
                    AL.get_leg_labels(), self._B_labels))
            if AR.get_leg_labels() != self._B_labels:
                raise ValueError("AR has wrong labels {0!r}, expected {1!r}".format(
                    AR.get_leg_labels(), self._B_labels))
            if AC.get_leg_labels() != self._B_labels:
                raise ValueError("AC has wrong labels {0!r}, expected {1!r}".format(
                    AC.get_leg_labels(), self._B_labels))
            AR.get_leg('vL').test_contractible(self._C[i].get_leg('vR'))
            AR.get_leg('vL').test_contractible(self._AC[(i - 1) % self.L].get_leg('vR'))
            AL.get_leg('vR').test_contractible(self._C[(i + 1) % self.L].get_leg('vL'))
            AL.get_leg('vR').test_contractible(self._AC[(i + 1) % self.L].get_leg('vL'))

        #if np.any(self._C[self.L].to_ndarray() != self._C[0].to_ndarray()): # TODO: There has got to be a better way to check equality of npc arrays.
        #    raise ValueError("uMPS with C[0] != C[L]")

        self.test_validity()

    def test_validity(self, cutoff=1.e-10):
        """Check AL C2 = C1 AR = AC

        To have a valid MPS and take measurements, we require this to be true. This will be true after VUMPS.
        """
        err = np.empty((self.L, 3), dtype=float)
        for i in range(self.L):
            AL, AR, AC, C1, C2 = self.get_AL(i), self.get_AR(i), self.get_AC(i), self.get_C(i), self.get_C(i+1)
            ALC2 = npc.tensordot(AL, C2, axes=['vR', 'vL']).itranspose(self._B_labels)
            C1AR = npc.tensordot(C1, AR, axes=['vR', 'vL']).itranspose(self._B_labels)
            err[i, 0] = npc.norm(ALC2 - C1AR)
            err[i, 1] = npc.norm(ALC2 - AC)
            err[i, 2] = npc.norm(C1AR - AC)
        self.valid_umps = np.max(err) < cutoff
        logger.info('uMPS is %s with max error %.5e.', 'valid' if self.valid_umps else 'invalid', np.max(err))
        return err

    def copy(self):
        """Returns a copy of `self`.

        The copy still shares the sites, chinfo, and LegCharges of the B tensors, but the values of
        B and S are deeply copied.
        """
        # __init__ makes deep copies of 4 types of tensors.
        cp = self.__class__(self.sites, self._AL, self._AR, self._AC, self._C, self.norm)
        cp.grouped = self.grouped
        cp._transfermatrix_keep = self._transfermatrix_keep
        cp.segment_boundaries = self.segment_boundaries
        return cp

    def save_hdf5(self, hdf5_saver, h5gr, subpath):
        """Export `self` into a HDF5 file.

        This method saves all the data it needs to reconstruct `self` with :meth:`from_hdf5`.

        Specifically, it saves
        :attr:`sites`,
        :attr:`chinfo` (under these names),
        :attr:`_B` as ``"tensors"``,
        :attr:`_S` as ``"singular_values"``,
        :attr:`bc` as ``"boundary_condition"``, and
        :attr:`form` converted to a single array of shape (L, 2) as ``"canonical_form"``,
        Moreover, it saves :attr:`norm`, :attr:`L`, :attr:`grouped` and
        :attr:`_transfermatrix_keep` (as "transfermatrix_keep") as HDF5 attributes, as well as
        the maximum of :attr:`chi` under the name "max_bond_dimension".

        Parameters
        ----------
        hdf5_saver : :class:`~tenpy.tools.hdf5_io.Hdf5Saver`
            Instance of the saving engine.
        h5gr : :class`Group`
            HDF5 group which is supposed to represent `self`.
        subpath : str
            The `name` of `h5gr` with a ``'/'`` in the end.
        """
        hdf5_saver.save(self.sites, subpath + "sites")
        hdf5_saver.save(self._AL, subpath + "tensors_AL")
        hdf5_saver.save(self._AR, subpath + "tensors_AR")
        hdf5_saver.save(self._AC, subpath + "tensors_AC")
        hdf5_saver.save(self._C, subpath + "tensors_C")
        hdf5_saver.save(self.chinfo, subpath + "chinfo")
        segment_boundaries = getattr(self, "segment_boundaries", (None, None))
        hdf5_saver.save(self.segment_boundaries, subpath + "segment_boundaries")
        h5gr.attrs["valid_umps"] = self.valid_umps
        h5gr.attrs["norm"] = self.norm
        h5gr.attrs["grouped"] = self.grouped
        h5gr.attrs["transfermatrix_keep"] = self._transfermatrix_keep
        h5gr.attrs["L"] = self.L  # not needed for loading, but still usefull metadata
        h5gr.attrs["max_bond_dimension"] = np.max(self.chi)  # same

    @classmethod
    def from_hdf5(cls, hdf5_loader, h5gr, subpath):
        """Load instance from a HDF5 file.

        This method reconstructs a class instance from the data saved with :meth:`save_hdf5`.

        Parameters
        ----------
        hdf5_loader : :class:`~tenpy.tools.hdf5_io.Hdf5Loader`
            Instance of the loading engine.
        h5gr : :class:`Group`
            HDF5 group which is represent the object to be constructed.
        subpath : str
            The `name` of `h5gr` with a ``'/'`` in the end.

        Returns
        -------
        obj : cls
            Newly generated class instance containing the required data.
        """
        obj = cls.__new__(cls)  # create class instance, no __init__() call
        hdf5_loader.memorize_load(h5gr, obj)

        obj.sites = hdf5_loader.load(subpath + "sites")
        obj._AL = hdf5_loader.load(subpath + "tensors_AL")
        obj._AR = hdf5_loader.load(subpath + "tensors_AR")
        obj._AC = hdf5_loader.load(subpath + "tensors_AC")
        obj._C = hdf5_loader.load(subpath + "tensors_C")
        obj.bc = 'infinite'
        obj.norm = hdf5_loader.get_attr(h5gr, "norm")
        obj.valid_umps = hdf5_loader.get_attr(h5gr, "valid_umps")

        obj.grouped = hdf5_loader.get_attr(h5gr, "grouped")
        obj._transfermatrix_keep = hdf5_loader.get_attr(h5gr, "transfermatrix_keep")
        obj.chinfo = hdf5_loader.load(subpath + "chinfo")
        obj.dtype = np.find_common_type([B.dtype for B in obj._AR], [])
        if "segment_boundaries" in h5gr:
            obj.segment_boundaries = hdf5_loader.load(subpath + "segment_boundaries")
        else:
            obj.segment_boundaries = (None, None)
        obj.test_sanity()
        return obj

    @classmethod
    def from_MPS(cls, psi):
        obj = cls.__new__(cls)
        obj.sites = list(psi.sites)
        obj.chinfo = psi.sites[0].leg.chinfo
        obj.dtype = psi.dtype
        obj.form = [None] * len(psi._B)
        obj.bc = psi.bc
        obj.norm = psi.norm
        obj.grouped = psi.grouped
        obj.segment_boundaries = psi.segment_boundaries
        obj.valid_umps = False # Need to check that AL[n] C[n+1] = AC[n] and C[n] AR[n] = AC[n]

        # make copies of 4 types of tensors
        obj._AR = [psi.get_B(i, form='B').astype(obj.dtype, copy=True).itranspose(obj._B_labels) for i in range(psi.L)]
        obj._AC = [psi.get_B(i, form='Th').astype(obj.dtype, copy=True).itranspose(obj._B_labels) for i in range(psi.L)]
        obj._AL = [psi.get_B(i, form='A').astype(obj.dtype, copy=True).itranspose(obj._B_labels) for i in range(psi.L)]
        obj._C = []
        for i in range(psi.L):
            C = npc.diag(psi.get_SL(i), obj._AL[i].get_leg('vL'), labels=['vL', 'vR']) # center matrix on the left of site `i`
            obj._C.append(C.astype(obj.dtype, copy=True).itranspose(obj._C_labels))

        obj._transfermatrix_keep = psi._transfermatrix_keep
        obj.test_sanity()
        return obj

    @classmethod
    def from_lat_product_state(cls, lat, p_state, **kwargs):
        raise NotImplementedError("Not valid for UMPS!")

    @classmethod
    def from_product_state(cls,
                           sites,
                           p_state,
                           bc='finite',
                           dtype=np.float64,
                           permute=True,
                           form='B',
                           chargeL=None):
        raise NotImplementedError("Not valid for UMPS.")

    @classmethod
    def from_Bflat(cls,
                   sites,
                   ALflat,
                   ARflat,
                   ACflat,
                   Cflat,
                   dtype=None,
                   permute=True,
                   legL=None):
        """Construct a matrix product state from a set of numpy arrays `Bflat` and singular vals.

        Parameters
        ----------
        sites : list of :class:`~tenpy.networks.site.Site`
            The sites defining the local Hilbert space.
        A{L,R,C}flat : iterable of numpy ndarrays
            The matrix defining the MPS on each site, with legs ``'p', 'vL', 'vR'``
            (physical, virtual left/right).
        Cflat : iterable of numpy ndarrays
            The matrix defining the bond matrix on each site, with legs ``'vL', 'vR'``
            (virtual left/right).
        dtype : type or string
            The data type of the array entries. Defaults to the common dtype of `Bflat`.
        permute : bool
            The :class:`~tenpy.networks.Site` might permute the local basis states if charge
            conservation gets enabled.
            If `permute` is True (default), we permute the given `Bflat` locally according to
            each site's :attr:`~tenpy.networks.Site.perm`.
            The `p_state` argument should then always be given as if `conserve=None` in the Site.
        leg_L : LegCharge | ``None``
            Leg charges at bond 0, which are purely conventional.
            If ``None``, use trivial charges.

        Returns
        -------
        mps : :class:`MPS`
            An MPS with the matrices `Bflat` converted to npc arrays.
        """
        sites = list(sites)
        L = len(sites)
        ALflat = list(ALflat)
        ARflat = list(ARflat)
        ACflat = list(ACflat)
        Cflat = list(Cflat)
        if len(ALflat) != L:
            raise ValueError("Length of ALflat does not match number of sites.")
        if len(ARflat) != L:
            raise ValueError("Length of ARflat does not match number of sites.")
        if len(ACflat) != L:
            raise ValueError("Length of ACflat does not match number of sites.")
        if len(Cflat) != L:
            raise ValueError("Length of Cflat does not match number of sites.")
        ci = sites[0].leg.chinfo
        if legL is None:
            legL = npc.LegCharge.from_qflat(ci, [ci.make_valid(None)] * Cflat[0].shape[0])
            legL = legL.bunch()[1]
        ALs = []
        ARs = []
        ACs = []
        Cs = []
        if dtype is None:
            dtype = np.dtype(np.common_type(*ALflat))
        for i, site in enumerate(sites):
            AL = np.array(ALflat[i], dtype)
            AR = np.array(ARflat[i], dtype)
            AC = np.array(ACflat[i], dtype)
            C = np.array(Cflat[i], dtype)
            if permute:
                AL = AL[site.perm, :, :]
                AR = AR[site.perm, :, :]
                AC = AC[site.perm, :, :]

            # calculate the LegCharge of the right leg of C
            Clegs = [legL, None]
            Clegs = npc.detect_legcharge(C, ci, Clegs, None, qconj=-1) # Even though C has no physical leg, it can have charge.
            C = npc.Array.from_ndarray(C, Clegs, dtype)
            C.iset_leg_labels(['vL', 'vR'])
            Cs.append(C)

            ARlegs = [site.leg, Clegs[-1].conj(), None]
            ARlegs = npc.detect_legcharge(AR, ci, ARlegs, None, qconj=-1)
            AR = npc.Array.from_ndarray(AR, ARlegs, dtype)
            AR.iset_leg_labels(['p', 'vL', 'vR'])
            ARs.append(AR)

            ALlegs = [site.leg, legL, None]
            ALlegs = npc.detect_legcharge(AL, ci, ALlegs, None, qconj=-1)
            AL = npc.Array.from_ndarray(AL, ALlegs, dtype)
            AL.iset_leg_labels(['p', 'vL', 'vR'])
            ALs.append(AL)

            AClegs = [site.leg, legL, None]
            AClegs = npc.detect_legcharge(AC, ci, AClegs, None, qconj=-1)
            AC = npc.Array.from_ndarray(AC, AClegs, dtype)
            AC.iset_leg_labels(['p', 'vL', 'vR'])
            ACs.append(AC)

            legL = ALlegs[-1].conj()  # prepare for next `i`

        # for an iMPS, the last leg has to match the first one.
        # so we need to gauge `qtotal` of the last `B` such that the right leg matches.
        # TODO Ask Johannes!
        chdiff = ALs[-1].get_leg('vR').charges[0] - AL[0].get_leg('vL').charges[0]
        ALs[-1] = ALs[-1].gauge_total_charge('vR', ci.make_valid(chdiff))
        ACs[-1] = ACs[-1].gauge_total_charge('vR', ci.make_valid(chdiff))

        chdiff = ARs[-1].get_leg('vR').charges[0] - ARs[0].get_leg('vL').charges[0]
        ARs[-1] = ARs[-1].gauge_total_charge('vR', ci.make_valid(chdiff))
        return cls(sites, ALs, ARs, ACs, Cs)

    @classmethod
    def from_full(cls,
                  sites,
                  psi,
                  form=None,
                  cutoff=1.e-16,
                  normalize=True,
                  bc='finite',
                  outer_S=None):
        raise NotImplementedError("Not valid for UMPS.")

    @classmethod
    def from_singlets(cls,
                      site,
                      L,
                      pairs,
                      up='up',
                      down='down',
                      lonely=[],
                      lonely_state='up',
                      bc='finite'):
        raise NotImplementedError("Not valid for UMPS.")

    #@property
    #def L(self):

    #@property
    #def dim(self):

    #@property
    #def finite(self):

    @property
    def chi(self):
        """Dimensions of the (nontrivial) virtual bonds."""
        # s.shape[0] == len(s) for 1D numpy array, but works also for a 2D npc Array.
        return [min(C.shape) for C in self._C[self.nontrivial_bonds]]

    def get_B(self, i, form='B', copy=False, cutoff=1.e-16, label_p=None):
        """Return (view of) `B` at site `i` in canonical form.

        Parameters
        ----------
        i : int
            Index choosing the site.
        form : ``'B' | 'A' | 'C' | 'G' | 'Th' | None`` | tuple(float, float)
            The (canonical) form of the returned B.
            For ``None``, return the matrix in whatever form it is.
            If any of the tuple entry is None, also don't scale on the corresponding axis.
        copy : bool
            Whether to return a copy even if `form` matches the current form.
        cutoff : float
            During DMRG with a mixer, `S` may be a matrix for which we need the inverse.
            This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
            singular values.
        label_p : None | str
            Ignored by default (``None``).
            Otherwise replace the physical label ``'p'`` with ``'p'+label_p'``.
            (For derived classes with more than one "physical" leg, replace all the physical leg
            labels accordingly.)

        Returns
        -------
        B : :class:`~tenpy.linalg.np_conserved.Array`
            The MPS 'matrix' `B` at site `i` with leg labels ``'vL', 'p', 'vR'``.
            May be a view of the matrix (if ``copy=False``),
            or a copy (if the form changed or ``copy=True``).

        Raises
        ------
        ValueError : if self is not in canoncial form and `form` is not None.
        """
        if form is None:
            return self.get_AR(i, copy=False, label_p=label_p)
        elif form=='A' or form==(1., 0.) or form=='AL':
            return self.get_AL(i, copy=False, label_p=label_p)
        elif form=='B' or form==(0., 1.) or form=='AR':
            return self.get_AR(i, copy=False, label_p=label_p)
        elif form=='Th' or form==(1., 1.) or form=='AC':
            return self.get_AC(i, copy=False, label_p=label_p)
        else:
            raise NotImplementedError("Form {0!r} is not valid for VUMPS.".format(form))

    #@property
    #def nontrivial_bonds(self):

    def get_AL(self, i, copy=False, label_p=None):
        i = self._to_valid_index(i)
        AL = self._AL[i]
        if copy:
            AL = AL.copy()
        if label_p is not None:
            AL = self._replace_p_label(AL, label_p)
        return AL

    def get_AR(self, i, copy=False, label_p=None):
        i = self._to_valid_index(i)
        AR = self._AR[i]
        if copy:
            AR = AR.copy()
        if label_p is not None:
            AR = self._replace_p_label(AR, label_p)
        return AR

    def get_AC(self, i, copy=False, label_p=None):
        i = self._to_valid_index(i)
        AC = self._AC[i]
        if copy:
            AC = AC.copy()
        if label_p is not None:
            AC = self._replace_p_label(AC, label_p)
        return AC

    def get_C(self, i, copy=False):
        """Return center matrix on the left of site `i`"""
        i = self._to_valid_index(i)
        C = self._C[i]
        if copy:
            C = C.copy()
        return C

    def set_B(self, i, B, form='B'):
        if form=='A' or form==(1., 0.) or form=='AL':
            return self.set_AL(i, B)
        elif form=='B' or form==(0., 1.) or form=='AR':
            return self.set_AR(i, B)
        elif form=='Th' or form==(1., 1.) or form=='AC':
            return self.set_AC(i, B)
        else:
            raise NotImplementedError("Form {0!r} is not valid for VUMPS.".format(list(form)))

    def set_AL(self, i, AL):
        i = self._to_valid_index(i)
        self.dtype = np.find_common_type([self.dtype, AL.dtype], [])
        self._AL[i] = AL.itranspose(self._B_labels)

    def set_AR(self, i, AR):
        i = self._to_valid_index(i)
        self.dtype = np.find_common_type([self.dtype, AR.dtype], [])
        self._AR[i] = AR.itranspose(self._B_labels)

    def set_AC(self, i, AC):
        i = self._to_valid_index(i)
        self.dtype = np.find_common_type([self.dtype, AC.dtype], [])
        self._AC[i] = AC.itranspose(self._B_labels)

    def set_C(self, i, C):
        i = self._to_valid_index(i)
        self.dtype = np.find_common_type([self.dtype, C.dtype], [])
        self._C[i] = C.itranspose(self._C_labels)

    def set_svd_theta(self, i, theta, trunc_par=None, update_norm=False):
        raise NotImplementedError("Not valid for UMPS.")

    def get_SL(self, i):
        return self.get_C(i)

    def get_SR(self, i):
        return self.get_C(i+1)

    def set_SL(self, i, S):
        self.set_C(i, S)

    def set_SR(self, i, S):
        self.set_C(i+1, S)

    #def get_op(self, op_list, i):

    def get_theta(self, i, n=2, cutoff=1.e-16, formL=1., formR=1.):
        """Calculates the `n`-site wavefunction on ``sites[i:i+n]``.
        Parameters
        ----------
        i : int
            Site index.
        n : int
            Number of sites. The result lives on ``sites[i:i+n]``.
        Returns
        -------
        theta : :class:`~tenpy.linalg.np_conserved.Array`
            The n-site wave function with leg labels ``vL, p0, p1, .... p{n-1}, vR``.
            In Vidal's notation (with s=lambda, G=Gamma):
            ``theta = s**form_L G_i s G_{i+1} s ... G_{i+n-1} s**form_R``.
        """
        i = self._to_valid_index(i)
        if n == 1:
            return self.get_B(i, (1., 1.), True, cutoff, '0')
        elif n < 1:
            raise ValueError("n needs to be larger than 0")
        # n >= 2: contract some B's
        theta = self.get_B(i, "AC", False, cutoff, '0')  # site i in Th form
        for k in range(1, n):  # non-empty range
            j = self._to_valid_index(i + k)
            B = self.get_B(j, "AR", False, cutoff, str(k))
            theta = npc.tensordot(theta, B, axes=['vR', 'vL'])
        return theta

    def convert_form(self, new_form='B'):
        raise NotImplementedError("Not valid for UMPS.")

    #def increase_L(self, new_L=None):

    def enlarge_mps_unit_cell(self, factor=2):
        """Repeat the unit cell for infinite uMPS boundary conditions; in place.

        Parameters
        ----------
        factor : int
            The new number of sites in the unit cell will be increased from `L` to ``factor*L``.
        """
        if int(factor) != factor:
            raise ValueError("`factor` should be integer!")
        if factor <= 1:
            raise ValueError("can't shrink!")
        if self.bc == 'segment':
            raise ValueError("can't enlarge segment MPS")
        self.sites = factor * self.sites
        self._AL = factor * self._AL
        self._AR = factor * self._AR
        self._AC = factor * self._AC
        self._C = factor * self._C
        self.test_sanity()

    def roll_mps_unit_cell(self, shift=1):
        """Shift the section we define as unit cellof an infinite MPS; in place.

        Suppose we have a unit cell with tensors ``[A, B, C, D]`` (repeated on both sites).
        With ``shift = 1``, the new unit cell will be ``[D, A, B, C]``,
        whereas ``shift = -1`` will give ``[B, C, D, A]``.

        Parameters
        ----------
        shift : int
            By how many sites to move the tensors to the right.
        """
        if self.finite:
            raise ValueError("makes only sense for infinite boundary conditions")
        inds = np.roll(np.arange(self.L), shift)
        self.sites = [self.sites[i] for i in inds]
        self._AL = [self._AL[i] for i in inds]
        self._AR = [self._AR[i] for i in inds]
        self._AC = [self._AC[i] for i in inds]
        self._C = [self._C[i] for i in inds]

    def spatial_inversion(self):
        """Perform a spatial inversion along the MPS.

        Exchanges the first with the last tensor and so on,
        i.e., exchange site `i` with site ``L-1 - i``.
        This is equivalent to a mirror/reflection with the bond left of L/2 (even L) or the site
        (L-1)/2 (odd L) as a fixpoint.
        For infinite MPS, the bond between MPS unit cells is another fix point.
        """
        self.sites = self.sites[::-1]
        self._AL = [
            AL.replace_labels(['vL', 'vR'], ['vR', 'vL']).transpose(self._B_labels)
            for AL in self._AL[::-1]
        ]
        self._AR = [
            AR.replace_labels(['vL', 'vR'], ['vR', 'vL']).transpose(self._B_labels)
            for AR in self._AR[::-1]
        ]
        self._AC = [
            AC.replace_labels(['vL', 'vR'], ['vR', 'vL']).transpose(self._B_labels)
            for AC in self._AC[::-1]
        ]
        self._C = [
            C.replace_labels(['vL', 'vR'], ['vR', 'vL']).transpose(self._C_labels)
            for C in self._C[::-1]
        ]
        self.test_sanity()
        return self

    def group_sites(self, n=2, grouped_sites=None):
        raise NotImplementedError("Not valid for UMPS.")

    def group_split(self, trunc_par=None):
        raise NotImplementedError("Not valid for UMPS.")

    def get_grouped_mps(self, blocklen):
        raise NotImplementedError("Not valid for UMPS.")

    def extract_segment(self, first, last):
        raise NotImplementedError("Not valid for UMPS.")

    def get_total_charge(self, only_physical_legs=False):
        """Calculate and return the `qtotal` of the whole MPS (when contracted).

        If set, the :attr:`segment_boundaries` are included (unless `only_physical_legs` is True).

        Parameters
        ----------
        only_physical_legs : bool
            For ``'finite'`` boundary conditions, the total charge can be gauged away
            by changing the LegCharge of the trivial legs on the left and right of the MPS.
            This option allows to project out the trivial legs to get the actual "physical"
            total charge.

        Returns
        -------
        qtotal : charges
            The sum of the `qtotal` of the individual `B` tensors.
        """
        assert only_physical_legs == False
        # Assume self.segment_boundaries is None, None for UMPS
        tensors_AL = self._AL
        qtotal_AL = np.sum([AL.qtotal for AL in tensors_AL], axis=0)
        qtotal_AL = self.chinfo.make_valid(qtotal_AL)

        tensors_AR = self._AR
        qtotal_AR = np.sum([AR.qtotal for AR in tensors_AR], axis=0)
        qtotal_AR = self.chinfo.make_valid(qtotal_AR)
        qtotal_AR.test_equal(qtotal_AL)

        return qtotal_AR

    def gauge_total_charge(self, qtotal=None, vL_leg=None, vR_leg=None):
        raise NotImplementedError("Who knows if this is valid for UMPS?")

    def entanglement_entropy(self, n=1, bonds=None, for_matrix_S=True):
        assert self.valid_umps
        assert for_matrix_S, "uMPS do not have diagonal C matrices."
        return super().entanglement_entropy(n, bonds, for_matrix_S)

    def entanglement_entropy_segment(self, segment=[0], first_site=None, n=1):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def entanglement_entropy_segment2(self, segment, n=1):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def entanglement_spectrum(self, by_charge=False):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def get_rho_segment(self, segment):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def probability_per_charge(self, bond=0):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def average_charge(self, bond=0):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def charge_variance(self, bond=0):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def mutinf_two_site(self, max_range=None, n=1):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def overlap(self, other, charge_sector=None, ignore_form=False, **kwargs):
        assert self.valid_umps
        assert not ignore_form, "uMPS have both forms. Use one."
        return super().overlap(other, charge_sector=None, ignore_form=False, **kwargs)

    def expectation_value(self, ops, sites=None, axes=None):
        assert self.valid_umps
        return super().expectation_value(ops, sites=sites, axes=axes)

    def expectation_value_term(self, term, autoJW=True):
        assert self.valid_umps
        return super().expectation_value_term(term, autoJW=autoJW)

    #def _term_to_ops_list(self, term, autoJW=True, i_offset=0, JW_from_right=False):

    def expectation_value_multi_sites(self, operators, i0):
        assert self.valid_umps
        return super().expectation_value_multi_sites(operators, i0)

    #def _corr_ops_LP(self, operators, i0):

    #def _corr_ops_RP(self, operators, i0):

    def expectation_value_terms_sum(self, term_list, prefactors=None):
        assert self.valid_umps
        return super().expectation_value_terms_sum(term_list, prefactors)

    def correlation_function(self,
                             ops1,
                             ops2,
                             sites1=None,
                             sites2=None,
                             opstr=None,
                             str_on_first=True,
                             hermitian=False,
                             autoJW=True):
        assert self.valid_umps
        return super().correlation_function(op1,
                                            ops2,
                                            sites1=sites1,
                                            sites2=sites2,
                                            opstr=opstr,
                                            str_on_first=str_on_first,
                                            hermitian=False,
                                            autoJW=autoJW)


    def term_correlation_function_right(self,
                                        term_L,
                                        term_R,
                                        i_L=0,
                                        j_R=None,
                                        autoJW=True,
                                        opstr=None):
        assert self.valid_umps
        return super().term_correlation_function_right(term_L,
                                                       term_R,
                                                       i_L=i_L,
                                                       j_R=j_R,
                                                       autoJW=autoJW,
                                                       opstr=opstr)

    def term_correlation_function_left(self,
                                        term_L,
                                        term_R,
                                        i_L=0,
                                        j_R=None,
                                        autoJW=True,
                                        opstr=None):
        assert self.valid_umps
        return super().term_correlation_function_left(term_L,
                                                      term_R,
                                                      i_L=i_L,
                                                      j_R=j_R,
                                                      autoJW=autoJW,
                                                      opstr=opstr)

    def term_list_correlation_function_right(self,
                                             term_list_L,
                                             term_list_R,
                                             i_L=0,
                                             j_R=None,
                                             autoJW=True,
                                             opstr=None):
        assert self.valid_umps
        return super().term_list_correlation_function_right(term_list_L,
                                                            term_list_R,
                                                            i_L=i_L,
                                                            j_R=j_R,
                                                            autoJW=autoJW,
                                                            opstr=opstr)

    def sample_measurements(self,
                            first_site=0,
                            last_site=None,
                            ops=None,
                            rng=None,
                            norm_tol=1.e-12):
        assert self.valid_umps
        return super().sample_measurements(self,
                                           first_site=0,
                                           last_site=None,
                                           ops=None,
                                           rng=None,
                                           norm_tol=1.e-12)

    def norm_test(self, force=False):
        if not force and not self.valid_umps:
            return np.zeros((self.L, 2), dtype=float)
        else:
            return super().norm_test()

    def canonical_form(self, **kwargs):
        raise NotImplementedError("Not valid for UMPS.")

    def canonical_form_finite(self, renormalize=True, cutoff=0., envs_to_update=None):
        raise NotImplementedError("Not valid for UMPS.")

    def canonical_form_infinite(self, renormalize=True, tol_xi=1.e6):
        raise NotImplementedError("Not valid for UMPS.")

    def correlation_length(self, target=1, tol_ev0=1.e-8, charge_sector=0):
        assert self.valid_umps
        return super().correlation_length(self, target=1, tol_ev0=1.e-8, charge_sector=0)

    def add(self, other, alpha, beta, cutoff=1.e-15):
        raise NotImplementedError("Not valid for UMPS.")

    def apply_local_op(self, i, op, unitary=None, renormalize=False, cutoff=1.e-13):
        raise NotImplementedError("Not valid for UMPS.")

    def apply_product_op(self, ops, unitary=None, renormalize=False):
        raise NotImplementedError("Not valid for UMPS.")

    def perturb(self, randomize_params=None, close_1=True, canonicalize=None):
        raise NotImplementedError("Not valid for UMPS.")

    def swap_sites(self, i, swap_op='auto', trunc_par=None):
        raise NotImplementedError("Not valid for UMPS.")

    def permute_sites(self, perm, swap_op='auto', trunc_par=None, verbose=None):
        raise NotImplementedError("Not valid for UMPS.")

    def compute_K(self,
                  perm,
                  swap_op='auto',
                  trunc_par=None,
                  canonicalize=1.e-6,
                  verbose=None,
                  expected_mean_k=0.):
        raise NotImplementedError("Convert uMPS to MPS for calculations involving S.")

    def __str__(self):
        """Some status information about the uMPS."""
        res = ["uMPS, L={L:d}, bc={bc!r}.".format(L=self.L, bc=self.bc)]
        res.append("chi: " + str(self.chi))
        res.append("valid: " + str(self.valid_umps))
        if self.L > 10:
            res.append("first two sites: " + repr(self.sites[0]) + " " + repr(self.sites[1]))
        else:
            res.append("sites: " + " ".join([repr(s) for s in self.sites]))
        return "\n".join(res)

    def compress(self, options):
        raise NotImplementedError("Not valid for UMPS.")

    def compress_svd(self, trunc_par):
        raise NotImplementedError("Not valid for UMPS.")

    #def _to_valid_index(self, i):

    #def _parse_form(self, form):

    #def _to_valid_form(self, form):

    def _scale_axis_B(self, B, S, form_diff, axis_B, cutoff):
        raise NotImplementedError("Not valid for UMPS.")

    #def _replace_p_label(self, A, s):

    #def _get_p_label(self, s):

    #def _get_p_labels(self, ks, star=False):

    #def _expectation_value_args(self, ops, sites, axes):

    #def _correlation_function_args(self, ops1, ops2, sites1, sites2, opstr):

    #def _corr_up_diag(self, ops1, ops2, i, j_gtr, opstr, str_on_first, apply_opstr_first):

    def _canonical_form_dominant_gram_matrix(self, bond0, transpose, tol_xi, guess=None):
        raise NotImplementedError("Not valid for UMPS.")

    def _canonical_form_correct_right(self, i1, Gr, eps=2. * np.finfo(np.double).eps):
        raise NotImplementedError("Not valid for UMPS.")

    def _canonical_form_correct_left(self, i1, Gl, Wr, eps=2. * np.finfo(np.double).eps):
        raise NotImplementedError("Not valid for UMPS.")

    def _gauge_compatible_vL_vR(self, other):
        raise NotImplementedError("Not valid for UMPS.")

    def _outer_virtual_legs(self):
        vL = self._AR[0].get_leg('vL')
        vR = self._AL[-1].get_leg('vR')
        return vL, vR
